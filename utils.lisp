(defun repeat (args)
  (declare (optimize (debug 3)))
  (declare (type list args))
  (labels ((repeat-help (l)
	     (if (null args)
		 l
		 (let* ((o (pop args))
			(n (pop args))
			(on (loop for i from 1 to n collect o)))
		   (repeat-help (append l on))))))
    (repeat-help nil)))

(defun flatten (l &optional (acc nil))
  (declare (type list l acc))
  "Return the flattened list (i.e. no more lists in the list)"
  (cond ((null l) acc)
	((consp (car l)) (flatten (cdr l) (nconc acc (flatten (car l)))))
	(t (flatten (cdr l) (nconc acc (list (car l)))))))

(defmacro timeit (&body body)
  (let* ((start (gensym))
	 (stop (gensym)))
    `(progn
       (let ((,start (get-internal-run-time)))
	 ,@body
	 (let ((,stop (get-internal-run-time)))
	   (- ,stop ,start))))))

(defmacro range (start &rest rest)
  "Return an as(des)cending number list like python range"
  (let ((incl (if (find :incl rest) t)))
    (declare (type boolean incl))
    (setq rest (delete :incl rest))
    (let ((start (if (= (length rest) 0) 0 start))
	  (stop (if (= (length rest) 0) start (car rest)))
	  (step (if (= (length rest) 2) (cadr rest) 1)))
      (let* ((i (gensym))
	     (stepsym (gensym))
	     (up (if incl 'upto 'below))
	     (down (if incl 'downto 'above)))
	(declare (type (or symbol real) start stop step))
	(cond ((not (numberp step))
	       `(let ((,stepsym ,step))
		  (if (> ,stepsym 0)
		      (loop for ,i from ,start ,up ,stop by ,stepsym collect ,i)
		      (loop for ,i from ,start ,down ,stop by (- ,stepsym)
			 collect ,i))))
	      ((> step 0)
	       `(loop for ,i from ,start ,up ,stop by ,step collect ,i))
	      ((< step 0)
	       `(loop for ,i from ,start ,down ,stop by (- ,step) collect ,i))
	      (t (error "range step must not be 0")))))))
